// @flow

import request from 'request';
import winston from 'winston';

interface Cache {
  add(url: string, error: Object, response: Object, body: Object): void;
  has(url: string): boolean;
  get(url: string): ?Object;
  clear(): void;
}

class Request {
  cache: Cache;

  /**
   *
   * @param {Object} cache
   */
  constructor(cache: Cache) {
    this.cache = cache;
  }

  /**
   *
   * @param {string} url
   * @param {boolean} followRedirect
   * @param {function} callback
   */
  get(url: string, followRedirect: boolean, callback: (error: Object, response: Object, body: Object) => void): Promise<any> {
    return new Promise((resolve, reject) => {
      if (!this.cache.has(url)) {
        winston.verbose('Requesting', url);
  
        request.get({ url: url, followRedirect: followRedirect }, (error, response, body) => {
          response.headers = this.keysToLowerCase(response.headers);
          this.cache.add(url, error, response, body);
  
          resolve({
            url: url,
            error: error,
            response: response,
            body: body,
          });
        });
      } else {
        winston.verbose('Returning from cache', url);
  
        const response = this.cache.get(url);
        resolve({
          url: url,
          error: error,
          response: response,
          body: body,
        });
      }
    });
  }



  /**
   *
   * @param {Object} obj
   * @returns {Object}
   */
  keysToLowerCase(obj: Object): Object {
    const result: Object = {};
    Object.keys(obj).forEach((key: string, value: any) => {
      result[key.toLowerCase()] = obj[key];
    });

    return result;
  }
}

export default Request;
