// @flow

import winston from 'winston';

type Namespace = {
  namespace: string,
  parent: ?Namespace,
};

type Test = {
  namespace: string,
  name: string,
  callback: Function,
};

class Pentest {
  namespaces: Array<Namespace>;

  tests: Array<Test>;

  constructor() {
    this.namespaces = [{
      namespace: 'root',
      parent: null,
    }];
    this.tests = [];
  }

  add(name: string, callback: Function | Object): void {
    winston.verbose('add(', name, ',', typeof callback, ')');
    if (typeof callback === 'function') {
      return this.addNamespace(name, callback);
    }
    return this.addTest(name, callback);
  }

  addNamespace(namespace: string, callback: Function): void {
    const parent = this.namespaces[0];
    this.namespaces.unshift({
      namespace: namespace,
      parent: parent,
    });
    callback();
    this.namespaces.shift();
  }

  addTest(name: string, callback: Object): void {
    const namespace = this.getNamespace(this.namespaces[0]);
    this.tests.push({
      namespace: namespace,
      name: name,
      callback: callback,
    });
    winston.debug('Add pentest ', namespace + '.' + name);
  }

  getNamespace(namespace: Namespace): string {
    const names = [];
    let n: ?Namespace = namespace;
    while (n !== null) {
      names.push(n.namespace);
      n = n.parent;
    }
    return names.reverse().join('.');
  }

  run(url: string, grep: string): Promise<any> {
    this.tests = this.tests.filter((test) => {
      return test.name.indexOf(grep) > -1 || test.namespace.indexOf(grep) > -1;
    });

    winston.verbose('URL: ', url);
    winston.verbose('Number of tests:', this.tests.length);

    return this.tests.reduce((promiseChain: Promise<any>, test: Object) => {
      return promiseChain.then((chainResults) => test.callback.execute(url).then((result) => {
        return [ ...chainResults, Object.assign({}, { name: test.namespace + '.' + test.name }, result) ];
      }));
    }, Promise.resolve([]));
  }
}

export default Pentest;
