import HTTPS from '../HTTPS';
import request from '../../request';
import { Result } from '../../Test';

test('HTTPS test with correct statusCode and location header', async () => {
  const https = new HTTPS();
  const mock = jest.spyOn(request, 'get').mockImplementation(async (): Promise<any> => {
    return new Promise((resolve) => {
      resolve({
        statusCode: 301,
        headers: {
          location: 'https://juffalow.com',
        },
      });
    });
  });

  const result = <Result> await https.run({ url: 'https://juffalow.com' });

  expect(result.status).toEqual('SUCCESS');

  mock.mockRestore();
});

test('HTTPS test with wrong statusCode', async () => {
  const https = new HTTPS();
  const mock = jest.spyOn(request, 'get').mockImplementation(async (): Promise<any> => {
    return new Promise((resolve) => {
      resolve({
        statusCode: 200,
        headers: {}
      });
    });
  });

  const result = <Result> await https.run({ url: 'https://juffalow.com' });

  expect(result.status).toEqual('ERROR');

  mock.mockRestore();
});

test('HTTPS test with correct statusCode but wrong redirect location', async () => {
  const https = new HTTPS();
  const mock = jest.spyOn(request, 'get').mockImplementation(async (): Promise<any> => {
    return new Promise((resolve) => {
      resolve({
        statusCode: 301,
        headers: {
          location: 'http://juffalow.com'
        }
      });
    });
  });

  const result = <Result> await https.run({ url: 'https://juffalow.com' });

  expect(result.status).toEqual('ERROR');

  mock.mockRestore();
});
