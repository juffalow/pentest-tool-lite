// @flow
import Result, { TYPE_OK, TYPE_INCORRECT, TYPE_ERROR } from '../../pentest/Result';
import UglifyJS from 'uglify-js';

export default class JavaScript {
  request: Object;
  parseHtml: Function;
  getResources: Function;
  logger: Object;
  
  /**
   * 
   * @param {Object} request
   * @param {Function} parseHtml
   * @param {Function} getResources
   * @param {Object} logger
   */
  constructor(request: Object, parseHtml: Function, getResources: Function, logger: Object) {
    this.request = request;
    this.parseHtml = parseHtml;
    this.getResources = getResources;
    this.logger = logger;
  }

  filterJavaScriptFiles(resources) {
    const regx = new RegExp('.*\\/([a-z0-9.])+(\\.js)((\\?)?(.*))', 'i');
    return resources.filter((resource) => {
      return regx.test(resource);
    });
  }

  isFileAvailable(result: Object): boolean {
    if (result.response.statusCode === 404 || result.response.statusCode === 500) {
      return false;
    }
    return true;
  }

  isCached(result: Object): boolean {
    return result.response.headers.hasOwnProperty('cache-control');
  }

  hasXContentTypeOptionsHeader(result: Object): boolean {
    return result.response.headers.hasOwnProperty('x-content-type-options');
  }

  hasConsoleLogs(result: Object): boolean {
    return result.body.indexOf('console.log') !== -1 && result.body.indexOf('console.error') !== -1;
  }

  isMinified(result: Object): boolean {
    const r = UglifyJS.minify(result.body, { mangle: false, output: { comments: true } });

    return result.body.length/* - (result.body.length * 0.05)*/ <= r.code.length;
  }

  isUglified(result: Object): boolean {
    const r = UglifyJS.minify(result.body);
  
    return result.body.length/* - (result.body.length * 0.02)*/ <= r.code.length;
  }

  async checkJavaScriptFile(url: string): Object {
    const result = await this.request.get(url);
    let tests = [];

    if (!this.isFileAvailable(result)) {
      tests = [...tests, new Result('available', TYPE_ERROR)];
      return new Result(url, TYPE_ERROR, tests);
    }

    tests = [...tests, new Result('available', TYPE_OK)];
    tests = [...tests, new Result('cache', this.isCached(result) ? TYPE_OK : TYPE_INCORRECT)];
    tests = [...tests, new Result('x-content-type-options', this.hasXContentTypeOptionsHeader(result) ? TYPE_OK : TYPE_INCORRECT)];
    tests = [...tests, new Result('console-logs', !this.hasConsoleLogs(result) ? TYPE_OK : TYPE_INCORRECT)];
    tests = [...tests, new Result('minify', this.isMinified(result) ? TYPE_OK : TYPE_INCORRECT)];
    tests = [...tests, new Result('uglify', this.isUglified(result) ? TYPE_OK : TYPE_INCORRECT)];

    return new Result(url, tests.filter(test => test.resultType !== TYPE_OK).length === 0 ? TYPE_OK : TYPE_INCORRECT, tests);
  }

  /**
   * 
   * @param {string} url
   * @returns {Object}
   */
  async execute(url: string): Object {
    this.logger.verbose('Executing JavaScript test...');

    const result = await this.request.get(url);
    const parsedHtml = await this.parseHtml(result);
    const resources = await this.getResources(parsedHtml);
    const files = this.filterJavaScriptFiles(resources);

    const results = await Promise.all(files.map(async (file) => await this.checkJavaScriptFile(file)));

    return new Result(url, results.filter(result => result.resultType !== TYPE_OK).length === 0 ? TYPE_OK : TYPE_INCORRECT, results);
  }
}