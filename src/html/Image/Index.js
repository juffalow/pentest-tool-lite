// @flow
import Result, { TYPE_OK, TYPE_INCORRECT, TYPE_ERROR } from '../../pentest/Result';

export default class Image {
  request: Object;
  parseHtml: Function;
  getResources: Function;
  logger: Object;
  
  /**
   * 
   * @param {Object} request
   * @param {Function} parseHtml
   * @param {Function} getResources
   * @param {Object} logger
   */
  constructor(request: Object, parseHtml: Function, getResources: Function, logger: Object) {
    this.request = request;
    this.parseHtml = parseHtml;
    this.getResources = getResources;
    this.logger = logger;
  }

  filterImageFiles(resources) {
    const regxJpg = new RegExp('.*\\/([a-z0-9.-])+(\\.jpg)((\\?)?(.*))', 'i');
    const regxJpeg = new RegExp('.*\\/([a-z0-9.-])+(\\.jpeg)((\\?)?(.*))', 'i');
    const regxPng = new RegExp('.*\\/([a-z0-9.-])+(\\.png)((\\?)?(.*))', 'i');
    const regxSvg = new RegExp('.*\\/([a-z0-9.-])+(\\.svg)((\\?)?(.*))', 'i');
    return resources.filter((resource) => {
      return regxJpg.test(resource) || regxJpeg.test(resource) || regxPng.test(resource) || regxSvg.test(resource);
    });
  }

  isFileAvailable(result: Object): boolean {
    if (result.response.statusCode === 404 || result.response.statusCode === 500) {
      return false;
    }
    return true;
  }

  isCached(result: Object): boolean {
    return result.response.headers.hasOwnProperty('cache-control');
  }

  hasXContentTypeOptionsHeader(result: Object): boolean {
    return result.response.headers.hasOwnProperty('x-content-type-options');
  }

  async checkImageFile(url: string): Object {
    const result = await this.request.get(url);
    let tests = [];

    if (!this.isFileAvailable(result)) {
      tests = [...tests, new Result('available', TYPE_ERROR)];
      return new Result(url, TYPE_ERROR, tests);
    }

    tests = [...tests, new Result('available', TYPE_OK)];
    tests = [...tests, new Result('cache', this.isCached(result) ? TYPE_OK : TYPE_INCORRECT)];
    tests = [...tests, new Result('x-content-type-options', this.hasXContentTypeOptionsHeader(result) ? TYPE_OK : TYPE_INCORRECT)];

    return new Result(url, tests.filter(test => test.resultType !== TYPE_OK).length === 0 ? TYPE_OK : TYPE_INCORRECT, tests);
  }

  /**
   * 
   * @param {string} url
   * @returns {Object}
   */
  async execute(url: string): Object {
    this.logger.verbose('Executing Image test...');

    const result = await this.request.get(url);
    const parsedHtml = await this.parseHtml(result);
    const resources = await this.getResources(parsedHtml);
    const files = this.filterImageFiles(resources);
    const results = await Promise.all(files.map(async (file) => await this.checkImageFile(file)));

    return new Result(url, results.filter(result => result.resultType !== TYPE_OK).length === 0 ? TYPE_OK : TYPE_INCORRECT, results);
  }
}