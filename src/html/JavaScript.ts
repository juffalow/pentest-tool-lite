import uglify from 'uglify-js';
import Test, { TestParameters, Result } from '../Test';
import request from '../request';
import logger from '../logger';
import { getScripts, parseHtml } from '../functions';

class JavaScript extends Test {

  public async test({ url }: TestParameters): Promise<Result> {
    logger.info(`Starting ${this.constructor.name} test...`);
    const response = await request.get(url);
    const html = await parseHtml(response);
    const scripts = getScripts(html);
    const subTests = await this.check(scripts);

    return {
      status: subTests.some(check => check.status === 'WARNING') ? 'WARNING' : 'SUCCESS',
      title: this.constructor.name,
      description: '',
      results: subTests,
    };
  }

  private async check(scripts: Array<string>): Promise<Array<Result>> {
    const results = [];

    for (const script of scripts) {
      const filename = script.substr(script.lastIndexOf('/') + 1);
      logger.verbose(`Checking ${filename}...`);

      const result = await request.get(script);

      const isFileAvailabe = {
        status: this.isFileAvailable(result) ? 'SUCCESS' : 'ERROR',
        title: 'Available',
        description: '',
      };
      const isCached = {
        status: this.isCached(result) ? 'SUCCESS' : 'ERROR',
        title: 'Cached',
        description: '',
      };
      const hasXContentTypeOptionsHeader = {
        status: this.hasXContentTypeOptionsHeader(result) ? 'SUCCESS' : 'WARNING',
        title: 'X-Content-Type-Options',
        description: '',
      };
      const isMinified = {
        status: this.isMinified(result) ? 'SUCCESS' : 'WARNING',
        title: 'Minified',
        description: '',
      };
      const hasConsoleLogs = {
        status: this.hasConsoleLogs(result) ? 'SUCCESS' : 'WARNING',
        title: 'Minified',
        description: '',
      };

      results.push({
        status: 'SUCCESS',
        title: filename,
        description: '',
        results: [
          isFileAvailabe,
          isCached,
          hasXContentTypeOptionsHeader,
          isMinified,
          hasConsoleLogs,
        ],
      });
    }

    return results;
  }

  protected isFileAvailable(result: any): boolean {
    if (result.response.statusCode === 404 || result.response.statusCode === 500) {
      return false;
    }
    return true;
  }

  protected isCached(result: any): boolean {
    return Object.prototype.hasOwnProperty.call(result.response.headers, 'cache-control');
  }

  protected hasXContentTypeOptionsHeader(result: any): boolean {
    return Object.prototype.hasOwnProperty.call(result.response.headers, 'x-content-type-options');
  }

  protected isMinified(result: any): boolean {
    const r = uglify.minify(result.body, { mangle: false, output: { comments: true } });

    if (Object.prototype.hasOwnProperty.call(r, 'error')) {
      logger.error('JavaScript syntax error!');
      throw r.error;
    }

    return result.body.length /* - (result.body.length * 0.05)*/ <= r.code.length;
  }

  protected hasConsoleLogs(result: any): boolean {
    return result.body.indexOf('console.log') !== -1 && result.body.indexOf('console.error') !== -1;
  }
}

export default JavaScript;
