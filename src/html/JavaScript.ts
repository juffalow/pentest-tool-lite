import Test from '../Test';
import UglifyJS from 'uglify-js';

class JavaScript extends Test {
  protected request: RequestInterface;

  protected parseHTML: Function;

  protected getResources: Function;

  protected logger: LoggerInterface;

  constructor(request: RequestInterface, parseHTML: Function, getResources: Function, logger: LoggerInterface) {
    super();
    this.request = request;
    this.parseHTML = parseHTML;
    this.getResources = getResources;
    this.logger = logger;
  }

  async run(url: string): Promise<ResultInterface> {
    this.logger.info('Starting JavaScript test...');
    const result = await this.request.get(url);
    const parsedHtml = await this.parseHTML(result);
    const resources = await this.getResources(parsedHtml);
    const files = this.filterJavaScriptFiles(resources);

    const subChecks = await Promise.all(files.map(async file => await this.checkFile(file)));

    return this.getResult('JavaScript', this.getStatus(subChecks), subChecks);
  }

  protected filterJavaScriptFiles(paths: Array<string>): Array<string> {
    const regx = new RegExp('.*\\/([a-z0-9.])+(\\.js)((\\?)?(.*))', 'i');
    return paths.filter((resource) => {
      return regx.test(resource);
    });
  }

  protected async checkFile(file: string): Promise<ResultInterface> {
    const filename = file.substr(file.lastIndexOf('/'));
    this.logger.debug(`Checking ${filename}...`);
    const result = await this.request.get(file);

    let minified: string;

    try {
      minified = this.isMinified(result) ? 'SUCCESSFUL' : 'UNSUCCESSFUL';
    } catch (exception) {
      minified = 'ERROR';
    }

    const subChecks = [
      this.getResult('Available', this.isFileAvailable(result) ? 'SUCCESSFUL' : 'UNSUCCESSFUL'),
      this.getResult('Cache-Control', this.isCached(result) ? 'SUCCESSFUL' : 'UNSUCCESSFUL'),
      this.getResult('X-Content-Type-Options', this.hasXContentTypeOptionsHeader(result) ? 'SUCCESSFUL' : 'UNSUCCESSFUL'),
      this.getResult('Minified', minified),
      this.getResult('Console', this.hasConsoleLogs(result) ? 'SUCCESSFUL' : 'WARNING'),
    ];

    return this.getResult(filename, this.getStatus(subChecks), subChecks);
  }

  protected isFileAvailable(result: any): boolean {
    if (result.response.statusCode === 404 || result.response.statusCode === 500) {
      return false;
    }
    return true;
  }

  protected isCached(result: any): boolean {
    return result.response.headers.hasOwnProperty('cache-control');
  }

  protected hasXContentTypeOptionsHeader(result: any): boolean {
    return result.response.headers.hasOwnProperty('x-content-type-options');
  }

  protected isMinified(result: any): boolean {
    const r = UglifyJS.minify(result.body, { mangle: false, output: { comments: true } });

    if (r.hasOwnProperty('error')) {
      this.logger.error('JavaScript syntax error!');
      throw new Error(r.error);
    }

    return result.body.length/* - (result.body.length * 0.05)*/ <= r.code.length;
  }

  hasConsoleLogs(result: any): boolean {
    return result.body.indexOf('console.log') !== -1 && result.body.indexOf('console.error') !== -1;
  }
}

export default JavaScript;
