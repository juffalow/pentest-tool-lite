// @flow

import request from 'request';
import winston from 'winston';

interface Cache {
  add(url: string, error: Object, response: Object, body: Object): void;
  has(url: string): boolean;
  get(url: string): ?Object;
  clear(): void;
}

class Request {
  cache: Cache;

  /**
   *
   * @param {Object} cache
   */
  constructor(cache: Cache) {
    this.cache = cache;
  }

  /**
   *
   * @param {string} url
   * @param {boolean} followRedirect
   * @param {function} callback
   */
  request(url: string, followRedirect: boolean, callback: (error: Object, response: Object, body: Object) => void) {
    if (!this.cache.has(url)) {
      winston.verbose('Requesting', url);

      request.get({ url: url, followRedirect: followRedirect }, (error, response, body) => {
        response.headers = this.keysToLowerCase(response.headers);
        this.cache.add(url, error, response, body);

        callback(error, response, body);
      });
    } else {
      winston.verbose('Returning from cache', url);

      const response = this.cache.get(url);
      callback(response.error, response.response, response.body);
    }
  }

  /**
   *
   * @param {Object} obj
   * @returns {Object}
   */
  keysToLowerCase(obj: Object): Object {
    const result: Object = {};
    Object.keys(obj).forEach((key: string, value: any) => {
      result[key.toLowerCase()] = obj[key];
    });

    return result;
  }
}

export default Request;
